# TIL(Today I Learned)

> 오늘 배운 내용을 정리하자

## [JAVA](./java)



## 12.09



모든 객체의 생성자에서는 부모 객체의 생성자를 들렸다 온다

`super`로 즉 `Object` 클래스의 생성자를 들렸다가 와서 생성됨.

생성자함수는 무조건 부모생성자 함수를 들렸다가 옴. `super`가 없으면 생략 되어있는것.

부모를 갖고 있으면 부모를 먼저 메모리 상단에 얹어지고 그다음 레퍼런스 `object.` 을 하게 되면 밑으로 부터 올라감 같은 변수의 부모에 있는것을

사용하고 싶으면 `super`를 사용, 

```java
class A{
    public String x(){return "A.x";}
}
class B extends A{
    public String x(){return "B.x";}
    public String y(){return "y";}
}
public class PolymorphismDemo1 {
    public static void main(String[] args) {
        A obj = new B();
        System.out.println(obj.x());
    }
}
```



클래스 B의 데이터 타입을 클래스 A로 인스턴스화 했을 때 클래스 B의 메소드 y는 마치 존재하지 않는 것처럼 실행되지 않았다.

 => 클래스 B가 클래스 A화 되었다.



클래스 B의 데이터 타입을 클래스 A로해서 인스턴스화 했을 때 클래스 B의 메소드 x를 실행하면 

클래스 A에서 정의된 메소드가 아니라 클래스 B에서 정의된 메소드가 실행 되었다. 

=> 클래스 B의 기본적인 성질은 그대로 간직하고 있다.



`this.kind` 인 `this`를 사용했을때 그 영역내에 변수가 없다면 부모의 클래스로 넘어가서 찾아봅니다.



### 오버로딩 vs 오버라이딩

**오버로딩 = 같은 클래스내에서 같은 이름의 메소드가 매개변수와 자료형이 다른것.**

**오버라이딩 = 부모로 부터 상속받은 메소드를 자식에 맞게 재구현 하는것!**



proected => 상속관계면 가능!



is a 관계와 has a 관계 -> 상속이거나 그안에서 객체 생성을 하는것.



### abstract class

`abstract class` 상속을 전제로 하여 짜여진 코드. 다른 클래스에서 상속을 받게되면 무조건 비어있는 `abstract` 클래스를 구현해야함.



> tip: 무언가 클래스를 설계할때는 `Object` 에 있는 `toString` 과 `equals` 를 적합하게 바꾸는것이 클래스 설계의 기초이다.



인터페이스는 메모리 힙 영역에 올라가지 않는다. 이름규칙은 ~~able 인터페이스는 다중상속이가능함 인터페이스끼리



이너클래스일 경우 class A{ class B } => A$B 라고 표현이 됩니당.



인터페이스 안의 추상메소드가 하나일때는 람다식으로 표현할 수 있음.



try() => 괄호안으로 반납해야 하는 자원을 넣어주면 자동으로 반납해줌. finall 안에 반납안해줘도 됨.



Clinet 에게 에러 메시지를 보여주거나 할때 main에서 보여줌. 메소드 안에서 try catch를 해결한다면 서버에서 해결하는것과 비슷.



**stack = LIFO** 라스티인퍼스트 아웃. 

**queue = FIFO** 퍼스트인 퍼스트 아웃



Java의 콜렉션

Set = *중복없이* 순서없이 객체를 삽입. = 주머니에 데이터를 본다고 생각하면됨. 

들어간 순서대로 데이터가 다시 나올 보장이없음.



LinkedList => 장점 : 삽입과 삭제가 쉬움 단점: 걍 확인이 느림. 엑세스 속도가 느림. 노드기반= 자료와 다음 주소를 가르키는 꼬리가있음.



Map = key 와 value => key는 중복되지않는다. 지도에서 좌표를 찾아가면 진짜 땅이 있는걸로 기억합시다. 내부적으로 키값을 찾아서 해당하는 벨류를 찾는것이 매우 빠름. 

## 기타

* [Git](https://github.com/choihwan2)
* Markdown
* 

