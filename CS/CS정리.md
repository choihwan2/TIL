# 기술 면접 준비

## 10월 20일
- [객체지향 프로그래밍(OOP)란 무엇인가](https://asfirstalways.tistory.com/177)
  
    - 현실세계를 프로그래밍으로 옮겨와 프로그래밍하는 것. 현실에서의 사물들을 객체, 그리고 그 특징들을 뽑아와 프로그래밍하는것 이게 추상화다.
      
    - 장점 : 재사용성이 높다, 내부적인 동작들을 몰라도 라이브러리를 사용할 수 있어 생산성이 높아진다.
      
    - 단점 : 객체 정보교환이 모두 메시지 교환을 통해 일어나므로 꽤 많은 overhead가 발생한다. 치명적인 단점으로는 객체가 상태를 갖게되고 이 객체가 예측할 수 없는 상태를 갖게 되면 에플리케이션 내에서 버그가 발생한다.
      
    - *클래스를 이용해 연관 있는 처리부분(함수)과 데이터 부분(변수)를 하나로 묶어 객체(인스턴스)를 생성해 사용한다는 점입니다.* 
    
      그리고 객체지향 프로그래밍에서는 프로젝트를 독립적인 객체 단위로 분리해서 작업할 수 있기 때문에 여러 개발자와 협업해 규모가 큰 프로젝트를 진행할 수 있으며 유지보수측면도 뛰어나다는장점이 있습니다.
    
- 객체지향의 SOLID 원칙

    - SRP (단일책임의 원칙)
        
        - 작성된 클래스는 하나의 기능만 가지며 모든 서비스는 그 하나의 책임을 수행하는데 집중되어 있어야한다.
        
    - OCP (개방폐쇄의 원칙)
        
        - 소프트웨어의 구성요소는 확장에는 열려있고, 변경에는 닫혀있어야한다.
        
    - LSP (리스코브 치환의 원칙)
        
        - 서브타입은 언제나 기반타입으로 교체할 수 있어야한다.(즉 자식은 언제나 부모 타입으로 바뀔수 있다?)
        
    - ISP (인터페이스 분리의 원칙)

        - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.

            각 클라이언트가 필요로 하는 인터페이스들을 분리함으로써, 각 클라이언트가 사용하지 않는 인터페이스에 변경이 발생하더라도 영향을 받지 않도록 만들어야 한다.

    - DIP (의존성역전의 원칙)

        - 즉, 저수준 모듈이 변경돼도 고수준 모듈은 변경할 필요가 없는 것이다.

- RESTful API (Representational State Transfer)

    - 자원(uri), 행위(verb), 표현(representation) 으로 이루어진것
    - 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것
    - 특징 여섯가지
        - uniform (유니폼 인터페이스) : 지정한 리소스에 대한 조작을 통일, 한정적인 인터페이스로 수행하는 아키텍쳐 스타일
        - stateless (무상태성) : API 서버는 들어오는 요청만을 단순히 처리하면 된다.
        - cacheable (캐시 가능) : 
        - self-descriptiveness
        - client - server : 클라이언트와 서버와의 데이터 송수신으로 이루어진다.
        - 계층형
    - URI는 자원을 표현하는 데에 집중하고 행위에 대한 정의는 HTTP METHOD를 통해 하는 것이 REST한 API를 설계하는 중심 규칙
    - 즉 , REST란, HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미 + API 데이터와 기능의 집합을 제공하여 프로그램간 상호작용 촉진, 정보 교환가능하도록 하는 설명서같은 역활, API는 프로그램과 또 다른 프로그램을 연결해주는 일종의 다리

- TDD란 무엇인가, 장점은??

- MVC 패턴

- [자바 언어에 대한 개념](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java)
  
    - [JVM, GC](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java)의 역할과 작동방식을 설명하시오
    - [Annotation](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Java#annotation)의 동작?
    - 자바에서 synchronized 구현하는 방식 두가지
    - final keyword
    - overloading, overriding
    - StringBuffer vs StringBuilder (vs String)

## 10월 21일 (수)
- 운영체제
    - 프로세스와 스레드의 차이 + 프로세스란? 스레드란?
      
        - 스레드에서 자원을 어떻게 공유하는지 설명하시오
    - Deadlock과 Starvation에 대해서 설명하고 -> 어떻게 해결?
        - 뮤텍스랑 세마포어
        - <iframe width="614" height="395" src="https://www.youtube.com/embed/PQ5aK5wLCQE" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    - 동기와 비동기의 차이
    - 멀티 스레드
    - Interpreter 와 compile 언어에 대해 설명하시오


## 10월 22일 (목)
- 네트워크
  - [OSI 7계층](https://blog.naver.com/PostView.nhn?blogId=pst8627&logNo=221670903384)에 대해 과 함께 웹 통신의 큰 흐름

  TCP/IP 로 통신을 하게 되면 위 계층부터 순서대로 거쳐 상대와 통신한다. 클라이언트 애플리케이션 계층인 HTTP에서 어느 웹 페이지를 보고 싶다라는 HTTP 리퀘스트를 지시한다. 그다음 트랜스포트 계층에서는 애플리케이션 계층에서 받은 데이터를 통신하기 쉽게 조각내어 안내 번호와 포트 번호를 붙여 네트워크 계층으로 전달한다. 네트워크 계층에서 수신지 MAC 주소를 추가해서 링크계층에 전달한다. 송신측은 계속해서 계층을 내려갈때 마다 헤더를 추가하고 상대는 사용한 헤더를 삭제한다. 

  - 전송을 담당하는 **IP**

    IP와 IP 주소는 다른것이다. IP는 프로토콜 => 개개의 패킷을 상대방에게 전달하는 것. 그중 IP 주소와 MAC 주소가 중요한데, IP 주소는 각 노드에 부여된 주소를 가르키고 MAC 주소는 각 네트워크 카드에 할당된 고유 주소이다. 기본적으로 MAC 주소는 변경이 불가능하다. 여러대의 컴퓨터와 중계를 통해서 상대방에게 도착하는데 이때 다음으로 중계할 곳의 MAC 주소를 사용해서 목적지를 찾아간다. 이때 ARP라는 프로토콜이 사용된다.

  - 신뢰성을 담당하는 **TCP**

    용량이 큰 데이터를 TCP 세그먼트라는 단위로 작게 분해하여 관리하고 상대방에서 보내고 정확하게 도착했는지 확인하는 역활을 한다. 쓰리웨이 핸드쉐이킹 방법을 사용. 보냈을때 SYN, SYN/ACK 로 응답받음. 마지막으로 송신측이 ACK를 보냄으로 패킷교환이 완료. 연결을 해제할때는 4 핸드쉐이킹이 사용된다. 

  - 이름 해결을 담당하는 **DNS**(전화번호부)

    영문의 도메인 명으로 IP 주소를 제공하거나 역으로 IP주소를 통해 도메인 명을 알려주는 서비스를 제공한다. 

![OSI 7계층 설명](https://i.imgur.com/nRrrGqW.png)

- 연결 / 해제에서 일어나는 3ways-handshaking, 4ways-handshaking에 대해 설명하시오
     - TCP 와 UDP 에 대해서 설명하시오
     
     - HTTP METHOD 정리해서 설명하시오
     
          - GET : URI 가 가지고 있는 정보 요청
          - POST : 요청을 보내지만 데이터부분에 요청 정보가 들어가서 보내진다.
          - PUT : 지정한 콘텐츠를 저장하기 위해 사용된다
          - HEAD : 웹서버의 유무와 서버 정보등을 얻기 위해 사용
          - DELETE : 웹서버에 있는 파일을 삭제하기 위해 사용
          - PATCH : 리소스의 부분만을 수정하는 데 쓰인다.
     
          그러면 뭐 암거나 써도 되는거아냐?? => 약속이다.
     
     - HTTP에서 사용해본 헤더나 사용되는 헤더들
          - 일반 헤더 (request나 response 둘다 사용 가능)
               - Cache-control - public(응답이 어떤 캐시에 의해서든 캐시로 저장된다.), private(공유캐시에의해 저장X), no-cache(원서버로 요청해서 무조건 새로운캐시), only-if-cached(새로운 데이터 X 무조건 캐시만)
               - Connection : 뒤에 오는 헤더는 더이상 전송하지 않는다, close 이제 연결을 끊낸다, keep-alive 연결을 계속할때 쓰는 헤더
               - Date : 생성된 날짜를 
               - via : 프록시를 경유할 경우 반드시 필요하다.
               - Referer 요청 헤더는 현재 요청된 페이지의 링크 이전의 웹 페이지 주소를 포함합니다. `Referer` 헤더는 사람들이 어디로부터 와서 방문 중인지를 인식할 수 있도록 해주며 해당 데이터는 예를 들어, 분석, 로깅, 혹은 캐싱 최적화에 사용될 수도 있습니다.
          - 리퀘스트 헤더
               - Accept : 가능하면 어떤 리소스로 받을건지 정하는 것.
               - Accept-Charset : 어떤 문자셋으로 읽고 싶을지 쓰는 헤더
               - Authorization : 유저의 인증 정보를 전달 하기 위해 사용
               - Range : 리소스의 일부분만 취득할때 사용되는 헤더
          - 리스폰스 헤더필드
               - Accept-Range : 리퀘스트에 Range 헤더가 있으면 응답하는 것으로 bytes(가능) none(불가능) 으로 응답
               - Location : 페이지가 이동되었을때 바뀐 곳을 알려준다. 대부분 3xx 에러와 함께 받으면 리다이렉트함
          - 엔티티 헤더필드
               - Allow : 사용가능한 메소드의 일람을 전달 (GET,POST, 등)
          - 타 자주사용되는 헤더필드
               - X-frame-Option : 다른 웹사이트의 프레임이에서 표시를 제어하는 HTTP 리스폰스 헤더 : 클릭재킹이라는 공격을 막을 수 있다. 속성으로는 DENY, SAMEORIGIN
               - X-XSS-Protection : 크로스 사이트 스크립팅(XSS) 대책으로 브라우저의 XSS 보호 기능을 제어하는 HTTP 리스폰스 헤더 , 속성으로는 0 : XSS 필터 무효, 1: XSS 필터 유효
          
     - DNS round robin 방식 [링크](https://github.com/gyoogle/tech-interview-for-developer/blob/master/Computer%20Science/Network/%EB%A1%9C%EB%93%9C%20%EB%B0%B8%EB%9F%B0%EC%8B%B1(Load%20Balancing).md)
     
     - 시간이 만약 된다면, round robin만 아니라 다른 알고리즘도 정리해보기
     
     - HTTP vs HTTPS
     
          - HTTPS 검색엔진 최적화
          - SSL TSL
     
     - 웹소켓 과 TCP 소켓의 차이
     
     - 쿠키와 세션
          - 쿠키 : 유저 식별과 유저의 상태를 관리하기 위해 사용되는 기능, 클라이언트 컴퓨터상에 저장하고 같은 웹사이트에 요청을 보낼시 딸려간다. 
               - Set-cookie 의 설정중 secure 을 넣게 되면 https 에서만 쿠키가 보내진다.
          
     - CORS 
     
     - 프록시 서버와 캐시 서버의 차이
## 10월 23일 (금)
- 자료구조

    - 배열
        - 메모리의 연속된 공간이 필요함. 첫번째 주소만 알면 원하는 메모리의 주소로 바로 찾아갈 수 있다.
    - HashMap
    - List, Set의 차이
    - HashMap와 TreeMap의 get 시간 복잡도
    - 어떤 구조? 어떻게 작동하는지?

- 데이터베이스
    - 데이터베이스를 사용하는 이유
    
        - 데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다. (현재도 부분적으로 사용되고 있다.) 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 한다. 이 때의 문제점은 데이터 종속성 문제와 중복성, 데이터 무결성이다.
    
            #### 데이터베이스의 특징
    
            1. 데이터의 독립성
    
               - 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없다.
               - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양항 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.
    
            2. 데이터의 무결성 여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성(정확성)을 구현하게 된다.
    
               > 무결성이란 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미한다
    
            3. 데이터의 보안성 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.
    
            4. 데이터의 일관성 연관된 정보를 논리적은 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있다.
    
            5. 데이터 중복 최소화 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.
    
    - Transaction이란 무엇인가?
    
        - 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
    
        - 상태 변화? **SQL 질의어를 통해 DB에 접근하는 것**
    
        - 원자성(Atomicity)
    
            > 트랜잭션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
    
        - 일관성(Consistency)
    
            > 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
    
        - 독립성(Isolation)
    
            > 둘 이상의 트랜잭션이 동시에 병행 실행되고 있을 때, 어떤 트랜잭션도 다른 트랜잭션 연산에 끼어들 수 없다.
    
        - 지속성(Durability)
    
            > 트랜잭션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.
    
    - Index
        - ### 인덱스(Index)란 무엇인가?
        
          인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인이라고 할 수 있다. 이 비유를 그대로 가져와서 인덱스를 살펴본다면 데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 될 것이다. DBMS 도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸린다. 그래서 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.
        
        - Index 의 성능과 고려해야할 사항
        
          DBMS 의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다. 결론적으로 DBMS 에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있다.  SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 된다.
        
          > 인덱스로 설정하는 필드의 속성이 중요하다. title, author 이 순서로 인덱스를 설정한다면 title 을 search 하는 경우, index 를 생성한 효과를 볼 수 있지만, author 만으로 search 하는 경우, index 를 생성한 것이 소용이 없어진다
        
        - #### B+-Tree 인덱스 알고리즘
        
          일반적으로 사용되는 인덱스 알고리즘은 B+-Tree 알고리즘이다. B+-Tree 인덱스는 칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리한다.), 원래의 값을 이용해 인덱싱하는 알고리즘이다.
        
    - 정규화
    
        - 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업이다. 좀 더 구체적으로는 불만족스러운 **나쁜** 릴레이션의 애트리뷰트들을 나누어서 **좋은** 작은 릴레이션으로 분해하는 작업을 말한다.
        - 
    
    - 교착상태
    
    - Statement vs PreparedStatement

## 10월 26일 (월)
- NoSQL vs RDBMS
- 위에서 부족한 내용들 + 이건 하고가자...

스터디진행과정정리
- 준비해온거 주고받기
- 다음날 할거 정하기





## 출처

[해설중 객체지향과 등등](https://github.com/gyoogle/tech-interview-for-developer)

[질문들](https://github.com/JaeYeopHan/Interview_Question_for_Beginner)

그림으로 배우는 Http & Network Basic 책