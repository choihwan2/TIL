# 1주차

- java의 특징

Wirte Once, Run Anywhere : 모든 플랫폼에서 독립적으로 작동이 가능하다. 바이트코드로 컴파일 => 자바 가상 머신만 있다면 어떤 운영체제에서도 사용할 수 있다.



Primitive vs Reference

P : 정적인 메모리 공간 사용

R : 동적(가변의) 메모리 공간 사용



10001001 => -119 

JAVA에서 첫번째 비트는 음수의 표현이다.



자바의 메서드 안에서는 절차식 => 순서대로 진행된다.



static => 객체 생성을 하지 않을 것이다.



main 메소드 => 시작점 entry point 반드시 있어야한다.



1byte => 8bite(한개의 공간에 0과 1 을 담을 수 있는 두가지) 01 7bite 2^7  -128 ~ 127 까지 표현 가능



배열의 크기를 구하는 것은 메소드가 아니다. arr.length <= 괄호가 없다.



쓸 수 있는 객체 new Fish() => heap 영역에 올라감. 인스턴스라고 한다.



연산할때는 스택에서 계산 , 클래스/스태틱/설계도 모두 다 스택에 올라간다. 멤버만 힙에 올라감.



## 7/21

Array is Immutable

- 최초 Memory Allocation 이후, 변경할 수 없음
- 변깅이 필요한 경우, 새로 작성하는 것이 일반적으로 유리함
- 크기를 늘리거나 줄일 수 없음.
- 개별 요소는 다른 값으로 변경이 가능하나, 삭제할 수는 없음.



자바는 두번 컴파일된다.

java -> class -> JVM 으로 들어가서 실행된다.



1차원 배열을 깊은 복사하는 법

.clone() 과 System.arraycopy 하지만 clone은 2차원부터는 안된다.



## 7/23

OOP(관점 지향 프로그래밍)

Encapsulation(캡슐화) : 하나의 클래스 안에 데이터와 기능을 담아 정리하고, 중요한 데이터나 복잡한 기능은 숨기고 외부에서 필요한 기능만을 공개하는 것

Ingeritance(상속성) : 객체 정의시 기존에 존재하는 객체의 속성과 기능을 상속받아 정의하는 것

Polymorphism(다형성) : 같은 타임 또는 같은 기능의 호출로 다양한 효과를 가져오는 것

Abstraction(추상화) : 현실 세계에 존재하는 객체의 주요 특증을 추출하는 과정





### **Class vs Object

#### Object

시스템의 대상이 되는 모든 것 , ex) 학생 관리 시스템에서 학생, 교사 , 출결, 성적 등등

=> **구체적**인 표현대상이 있다. 학생 Object라면 => A학생, B학생 등으로 표현 // 상품Object라면 => A상품, B상품



#### Class

구체적인 Object들중 분석해보고 공통적인 내용들을 **추상화**해서 programming 언어로 표현한 것이 바로 Class

=> 우선 시스템의 대상이 되는 현실 세계의 Object들을 분석한 다음, 그들을 어떤 기준에 의해, **분류(Classify)**를 하는 것이 먼저 해야함.

=> 분류 이후 Class 만의 **정적인 특성**과 **동적인 특성**을 파악해야한다.

- 정적인 특성 : attribute

- 동적인 특성 : behavior

예를 들면 휴대폰인 갤럭시 노트를 생각해보자.

쇼핑몰에서는  정적인 특성으로 이름, 색상, 가격인 attribute 와 할부원금()을 구하는 behavior가 필요하다. 또 다른 예로는 제조관리에서는 Serial No, 재질, 조립 등이 attribute가, 불량확인()을 하는 behavior 가 정의될 수 있다. 즉, 상황에 따라서 다르게 구축된다는 것을 보여준다.



Java에서의 클래스

new -> 뒤의 생성자를 보고 그에 맞는 memory allocation을 수행한다.



Class가 제공하는 생성자가 없을 경우, 즉 아무런 생성자가 없으면 Compier가 기본생성자를 자동으로 만들어준다. 하지만 우리가 생성자를 만든다면? Compiler는 아무런 생성자도 만들어 주지 않는다.



#### Member variables

Class 를 이용해서 Object들을 만든다는 건, 표현해야할 대상이 존재한다는 것. member variables를 통해 그 대상의 다양한 **상태**를 표현합니다!





#### 자바의 메모리 공간

class/설계도/거푸집/붕어빵틀 => static / 메서드 영역



stack => Thread



멤버변수는 힙에 생긴다. Heap 



Fish 		f		= 	new			Fish();



자바에서는 투포인터로 객체와 연결된다.

House h => 스택에 h가 1000이라는 값을 가르킨다. stack과 힙을 연결하는 hashtable이 하나 생긴다고 보면된다.

1000의 값을 따라가면 heap영역의 고유한 주소값을 가르킨다.

초기화 된다음 메모리의 주소를 받는다.



String은 생성되면 Heap 안에 있는 pool 영역에 생성된다.

String a = "1000", Stinrg b = "1000" 했을때, a== b 는 true 가 나온다.

하지만 String c = new String("1000") 을 한 경우 a==c 경우 false 가 나온다. 그 이유는

new String() 라는게 pool에 들어가지 않고 힙영역에 생성되어서 pool안에 있는 "1000"을 가르키기때문

그러다보니 .equals() 라는 메소드를 사용시 세 개다 같은 hashcode의 값을 같기때문에 true가 출력된다.



설계도 static에 올라가고 힙영역에 생성되고 초기화 되고 그다음 해쉬코드 받고 그다음 레퍼런스 연결

메모리 특징

1. 자생부생 (자식이 생성되면 부모가 생성된다.) **생성자는**! 부모생성자 -> 자식 생성자! (자식생성자 안에 super가 들어있기 때문) 
2. 자설부설 (static) (자식의 설계도가 올라가면 부모의 설계도도 올라간다.) 
3. 생주부주 (생성된 주소는 부모주소) 자식이 생성되어서 힙에 올라가면 부모의 주소를 가르키고있따.
4. 설공메사 (설계도에 공개된 메소드만 사용가능하다) class에 쓰여져있는것만 



static => 객체를 만들지 않고 메소드 호출이 가능하게함. 해당 클래스의 객체를 생성하지 않고 직접 접근하여 사용 주로 Object를 만들필요가 없는 곳에서 사용



#### GC(Garbage Collection)

Java 는 new 연산자를 통해 Memory Allocation 을 수행하지만 Deallocation은 JVM이 알아서 처리합니다.



개발자는 

- Garbage Collection에 직접 관여 할 수 없다.
- 자동으로 처리된다는 점은 Coding 관점에서는 장점이지만, 운영 관점에서는 단점
- 불필요한 객체 생성을 지양하자.



#### String

